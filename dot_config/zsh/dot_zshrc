# Zsh settings for interactive shells.

# Auto-start tmux on Wayland.
if [[ -n $WAYLAND_DISPLAY ]] && [[ -z $TMUX ]] && [[ -z $NO_TMUX ]]; then
    exec env tmux new-session -A -s 0
fi

# Zsh options.
setopt \
  append_history \
  share_history \
  extended_history \
  histignorespace \
  hist_find_no_dups \
  hist_ignore_all_dups \
  hist_reduce_blanks \
  no_case_glob \
  extended_glob \
  noglobdots \
  correct \
  completeinword \
  longlistjobs \
  notify \
  hash_list_all \
  nohup \
  auto_pushd \
  pushd_ignore_dups \
  prompt_subst \
  nobeep \
  noshwordsplit \
  noclobber \
  unset \

# Zsh history variables.
HISTFILE=$ZDOTDIR/.zhistory
HISTSIZE=100000
SAVEHIST=$HISTSIZE

# Prompt
function hline {
  print ${(pl:$COLUMNS::\u2500:)}
}
function last_exit_code() {
  local EXIT_CODE=$?
  if [[ $EXIT_CODE -ne 0 ]]; then
    echo "[$EXIT_CODE] "
  fi
}
function venv_status {
  if [[ -n "$VIRTUAL_ENV" ]]; then
    echo "(venv) "
  fi
}
function nix_shell_status {
  if [[ -n "$IN_NIX_SHELL" ]]; then
    echo "(nix) "
  fi
}
function cave_status {
  if [[ -n "$CODING_CAVE_VERSION" ]]; then
    echo "(cave) "
  fi
}
function width {
  echo $(( COLUMNS - 24 ))
}
function ssh_hostname {
  if [[ -n "$SSH_TTY" ]]; then
    echo "%n@%M:"
  fi
}
function prompt_char {
  if [[ $EUID -eq 0 ]]; then
    echo '%F{1}#'
  else
    echo '%F{4}$'
  fi
}
PROMPT='%F{237}$(hline)'$'\n''%K{237}$(prompt_char)%f%k '
PROMPT2='%K{237}%F{4}%_>%f%k '
RPROMPT='%F{5}$(last_exit_code)$(nix_shell_status)$(venv_status)$(cave_status)%$(width)<â€¦<$(ssh_hostname)%~%<<%f'

# Plugins.
autoload -Uz \
  compinit \
  up-line-or-beginning-search down-line-or-beginning-search
compinit
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' completer _expand_alias _complete _ignored

zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search

# Key bindings.
bindkey -e
bindkey '^P' up-line-or-beginning-search
bindkey '^N' down-line-or-beginning-search

# Aliases.
if command -v nix-shell &>/dev/null; then
    alias nix-shell='nix-shell --command zsh'
fi
alias ls='eza'
alias i='eza'
alias ll='eza -l'
alias la='eza -a'
alias lla='eza -la'
alias diff='diff --color=auto'
alias du='dust'
alias grep='grep --color=auto'
alias ip='ip -color=auto'
alias less='less -w'
alias tar='tar --keep-old-files'
alias veracrypt='veracrypt --text'
alias vim='nvim'
alias cal='cal --monday --year --week'
alias fast='fast --upload --single-line'

# When not in a pipe, run sudo -v to refresh timeout.
sudo() {
    if [[ -t 0 ]]; then
        command sudo -v
    fi
    command sudo "$@"
}

# Backups.
restic() {
    RESTIC_REPOSITORY=gs:cwo-restic:/ \
    RESTIC_PASSWORD_FILE="$HOME/.keys/restic-password" \
    GOOGLE_PROJECT_ID=restic-377922 \
    GOOGLE_APPLICATION_CREDENTIALS="$HOME/.keys/restic-service-account-key.json" \
    command restic "$@"
}

backup() {
    local args=(--exclude-file="$HOME/.config/restic/excludes.txt" "$HOME/files" "$@")
    local usb_repo=/mnt/usb/restic-repo
    if [[ -d $usb_repo ]]; then
        echo "==> Backing up to USB ($usb_repo)"
        restic --repo="$usb_repo" backup "${args[@]}"
    fi
    echo "==> Backing up to Google Cloud (gs:cwo-restic:/)"
    restic backup "${args[@]}"
}

# Execute private zshrc.
ZSH_PRIVATE=~/.config/zsh/.zshrc_private
if [[ -f $ZSH_PRIVATE ]]; then
    source $ZSH_PRIVATE
fi

# direnv, per-directory configuration during cd. https://direnv.net/
if command -v direnv &>/dev/null; then
    eval "$(direnv hook zsh)"
fi

# vim: set ts=2 sts=2 sw=2 expandtab:
